/////////////////////////////////////////////////////////////////////////////////////////////
// Copyright 2022 Garmin International, Inc.
// Licensed under the Flexible and Interoperable Data Transfer (FIT) Protocol License; you
// may not use this file except in compliance with the Flexible and Interoperable Data
// Transfer (FIT) Protocol License.
/////////////////////////////////////////////////////////////////////////////////////////////
// ****WARNING****  This file is auto-generated!  Do NOT edit this file.
// Profile Version = 21.94Release
// Tag = production/akw/21.94.00-0-g0f668193
/////////////////////////////////////////////////////////////////////////////////////////////


package com.garmin.fit.csv;

import com.garmin.fit.*;
import com.garmin.fit.plugins.ActivityFileValidationPlugin;
import com.garmin.fit.plugins.ActivityFileValidationResult;

import java.io.FileInputStream;
import java.io.InputStream;
import java.io.File;
import java.util.Arrays;
import java.util.HashSet;

public class CSVTool {

    private final int DATA_OR_DEFINITION_SEARCH_COUNT = 2;
    private String inputFileName = "";
    private String outputFileName = "";
    private HashSet<String> mesgDefinitionsToOutput = new HashSet<String>();
    private HashSet<String> dataMessagesToOutput = new HashSet<String>();
    private MesgDataCSVWriter dataMesgWriter = null;
    private MesgCSVWriter mesgWriter;
    private MesgFilter mesgFilter;
    private CSVDataMesgFieldCounter csvDataMesgFieldCounter;
    private boolean printBytesAsHex = false;
    private boolean printDateTimeAsISO8601 = false;
    private boolean printSemicirclesAsDegrees = false;
    private boolean fitToCsv = false;
    private boolean csvToFit = false;
    private boolean test = false;
    private boolean checkIntegrity = false;
    private boolean showInvalidValues = false;
    private boolean invalidsToEmpty = false;
    private boolean hideUnknownData = false;
    private boolean generateDataFile = false;
    private boolean enumsAsStrings = false;
    private boolean removeExpandedFields = false;
    private boolean excludeMesgList = false; // by default, the --defn and --data are include filters.
    private int nextArgumentDefinition = 0;
    private int nextArgumentData = 0;
    private int numUnknownFields = 0;
    private int numUnknownMesgs = 0;
    private Decode decode = new Decode();
    private Fit.ProtocolVersion protocolVersion = Fit.ProtocolVersion.V1_0;

    private CSVTool() {
    }

    private void run(String args[]) {

        int arg = 0;

        System.out.printf("FIT CSV Tool - Protocol %d.%d Profile %.2f %s\n", Fit.PROTOCOL_VERSION_MAJOR, Fit.PROTOCOL_VERSION_MINOR, Fit.PROFILE_VERSION / 100.0, Fit.PROFILE_TYPE);

        while (arg < args.length) {
            if (args[arg].equals("-b")) {
                if ((args.length - arg) < 3) {
                    printUsage();
                    return;
                }

                fitToCsv = true;
                inputFileName = args[arg + 1];
                outputFileName = args[arg + 2];

                arg += 2;
            }
            else if (args[arg].equals("-c")) {
                if ((args.length - arg) < 3) {
                    printUsage();
                    return;
                }

                csvToFit = true;
                inputFileName = args[arg + 1];
                outputFileName = args[arg + 2];

                arg += 2;
            }
            else if (args[arg].equals("-t")) {
                test = true;
            }
            else if (args[arg].equals("-d")) {
                Fit.debug = true;
                test = true;
            }
            else if (args[arg].equals("-i")) {
                checkIntegrity = true;
            }
            else if (args[arg].equals("-ex")) {
                excludeMesgList = true;
            }
            else if (args[arg].equals("--defn")) {
                nextArgumentDefinition = DATA_OR_DEFINITION_SEARCH_COUNT;
            }
            else if (args[arg].equals("--data")) {
                nextArgumentData = DATA_OR_DEFINITION_SEARCH_COUNT;
                generateDataFile = true;
            }
            else if (args[arg].charAt(0) != '-') {

                if (nextArgumentDefinition > 0) {
                    mesgDefinitionsToOutput = new HashSet<String>(Arrays.asList(args[arg].toLowerCase().split(",")));
                }
                else if (nextArgumentData > 0) {
                    dataMessagesToOutput = new HashSet<String>(Arrays.asList(args[arg].toLowerCase().split(",")));
                }
                else {
                    inputFileName = args[arg];
                    if (inputFileName.endsWith(".fit")) {
                        fitToCsv = true;
                        outputFileName = inputFileName.substring(0, inputFileName.length() - 4) + ".csv";
                    }
                    else if (inputFileName.endsWith(".csv")) {
                        csvToFit = true;
                        outputFileName = inputFileName.substring(0, inputFileName.length() - 4) + ".fit";
                    }
                }
            }
            else if (args[arg].equals("-s")) {
                showInvalidValues = true;
            }
            else if (args[arg].equals("-se")) {
                showInvalidValues = true;
                invalidsToEmpty = true;
            }
            else if (args[arg].equals("-u")) {
                hideUnknownData = true;
            }
            else if (args[arg].equals("-x")) {
                printBytesAsHex = true;
            }
            else if (args[arg].startsWith("-p")) {
                if (args[arg].endsWith("1")) {
                    protocolVersion = Fit.ProtocolVersion.V1_0;
                }
                else if (args[arg].endsWith("2")) {
                    protocolVersion = Fit.ProtocolVersion.V2_0;
                }
                else {
                    System.out.println("Unknown Protocol Version.");
                }
            }
            else if (args[arg].equals("-e")) {
                enumsAsStrings = true;
            }
            else if (args[arg].equals("-re")) {
                removeExpandedFields = true;
            }
            else if (args[arg].equals("-deg")) {
                printSemicirclesAsDegrees = true;
            }
            else if (args[arg].equals("-iso8601")) {
                printDateTimeAsISO8601 = true;
            }

            if (nextArgumentDefinition > 0) {
                nextArgumentDefinition--;
                if ((nextArgumentDefinition == 0) && (mesgDefinitionsToOutput.isEmpty())) {
                    System.out.println("No mesg definitions defined for --defn option.  Use 'none' if no definitions are desired.");
                    return;
                }
            }

            if (nextArgumentData > 0) {
                nextArgumentData--;
                if ((nextArgumentData == 0) && (dataMessagesToOutput.isEmpty())) {
                    System.out.println("No data messages defined for --data option.");
                    return;
                }
            }
            arg++;
        }

        if (inputFileName.isEmpty()) {
            System.out.println("No input file was provided!");
            printUsage();
            return;
        }
        File file = new File(inputFileName);
        if (!file.exists()) {
            System.out.println("Unable to find file: " + inputFileName);
            printUsage();
            return;
        }

        if (fitToCsv) {
            if ((outputFileName.length() >= 4) && (outputFileName.substring(outputFileName.length() - 4, outputFileName.length()).compareTo(".csv") == 0)) {
                outputFileName = outputFileName.substring(0, outputFileName.length() - 4); // Remove .csv extension.
            }

            if (checkIntegrity) {
                try {
                    if (!decode.checkFileIntegrity((InputStream) new FileInputStream(inputFileName))) {
                        if (!decode.getInvalidFileDataSize()) {
                            throw new RuntimeException("FIT file integrity failure.");
                        }
                        else {
                            System.out.println("FIT file integrity failure. Invalid file size in header.");
                            System.out.println("Trying to continue...");
                        }
                    }
                } catch (java.io.IOException e) {
                    throw new RuntimeException(e);
                }
            }

            if (test) {
                runVerificationTests();
            }

            try {
                //CSV Writer writes all messages to the csv file
                setupCsvWriter();
                if (generateDataFile) {
                    //Data Writer writes the data filtered messages
                    setupDataWriter();
                }
                FileInputStream fileInputStream = new FileInputStream(inputFileName);
                if (showInvalidValues == true) {
                    decode.showInvalidValues();
                }

                mesgFilter = new MesgFilter();
                csvDataMesgFieldCounter = new CSVDataMesgFieldCounter();
                if (excludeMesgList) {
                    mesgFilter.setMesgDefinitionsToIgnore(mesgDefinitionsToOutput);
                    mesgFilter.setDataMessagesToIgnore(dataMessagesToOutput);
                }
                else {
                    mesgFilter.setMesgDefinitionsToOutput(mesgDefinitionsToOutput);
                    mesgFilter.setDataMessagesToOutput(dataMessagesToOutput);
                }

                registerListenersForCsvWriter();
                registerListenersForDataWriter();

                while (decode.bytesAvailable((InputStream) fileInputStream)) { // Try to read a file while more data is available.
                    try {
                        decode.read((InputStream) fileInputStream);
                        decode.nextFile(); // Initialize to read next file (if any).
                    } catch (FitRuntimeException e) {
                        if (decode.getInvalidFileDataSize()) {
                            // The exception might be due to a bad file size written
                            // by a device. Retry the decoding process.
                            decode.nextFile();
                            continue;
                        }
                        else {
                            // An actual exception has occurred.
                            throw e;
                        }
                    }
                }
                if (dataMesgWriter != null) {
                    dataMesgWriter.setMaxNumFields(csvDataMesgFieldCounter.getMaxNumFields());
                }
                csvDataMesgFieldCounter.flushMesgs();

            } catch (Exception e) {
                System.out.printf("Error: A problem occurred while decoding the file. The decoded csv file may be truncated %s*.csv files.\n", outputFileName);
                if (Fit.debug)
                    e.printStackTrace(System.out);
            } finally {
                if (!mesgWriter.csvHasData()) {
                    System.out.println("Warning: No CSV has been written as this file does not contain FIT message data");
                }

                numUnknownFields = mesgWriter.getNumUnknownFields();
                numUnknownMesgs = mesgWriter.getNumUnknownMesgs();

                cleanupCsvWriter();
                cleanupDataWriter();

                if (hideUnknownData) {
                    System.out.printf("Hid %d unknown field(s) and %d unknown message(s).\n", numUnknownFields, numUnknownMesgs);
                }
            }

            System.out.printf("FIT binary file %s decoded to %s*.csv files.\n", inputFileName, outputFileName);
        }
        else if (csvToFit) {
            try {
                FileEncoder encoder = new FileEncoder(new File(outputFileName), protocolVersion);
                if (!CSVReader.read((InputStream) new FileInputStream(inputFileName), encoder, encoder, protocolVersion)) {
                    throw new RuntimeException("FIT encoding error.");
                }

                encoder.close();

                System.out.printf("%s encoded into FIT binary file %s.\n", inputFileName, outputFileName);
            } catch (java.io.IOException e) {
                throw new RuntimeException(e);
            }
        }
        else {
            printUsage();
        }
    }

    private void setupCsvWriter() {
        mesgWriter = new MesgCSVWriter(outputFileName + ".csv");
        if (invalidsToEmpty) {
            mesgWriter.showInvalidsAsEmptyCells();
        }
        if (hideUnknownData) {
            mesgWriter.hideUnknownData();
        }
        if (enumsAsStrings) {
            mesgWriter.enumsAsStrings();
        }
        if (removeExpandedFields) {
            mesgWriter.removeExpandedFields();
        }

        mesgWriter.setPrintSemicirclesAsDegrees(printSemicirclesAsDegrees);
        mesgWriter.setPrintByteAsHex(printBytesAsHex);
        mesgWriter.setPrintDateTimeAsISO8601(printDateTimeAsISO8601);
    }

    private void registerListenersForCsvWriter() {
        mesgFilter.addListener((MesgDefinitionListener) mesgWriter);
        mesgFilter.addListener((MesgListener) mesgWriter);

        decode.addListener((MesgDefinitionListener) mesgFilter);
        decode.addListener((MesgListener) mesgFilter);
    }

    private void cleanupCsvWriter() {
        mesgWriter.close();
    }

    private void setupDataWriter() {
        dataMesgWriter = new MesgDataCSVWriter(outputFileName + "_data.csv");
        if (invalidsToEmpty) {
            dataMesgWriter.showInvalidsAsEmptyCells();
        }
        if (hideUnknownData) {
            dataMesgWriter.hideUnknownData();
        }
        if (enumsAsStrings) {
            mesgWriter.enumsAsStrings();
        }
        if (removeExpandedFields) {
            dataMesgWriter.removeExpandedFields();
        }
        if (printSemicirclesAsDegrees) {
            dataMesgWriter.setPrintSemicirclesAsDegrees(true);
        }
        if (printDateTimeAsISO8601) {
            dataMesgWriter.setPrintDateTimeAsISO8601(true);
        }
    }

    private void registerListenersForDataWriter() {
        if (dataMesgWriter != null && csvDataMesgFieldCounter != null) {
            mesgFilter.addListener((MesgListener) csvDataMesgFieldCounter);
            csvDataMesgFieldCounter.addListener((MesgListener) dataMesgWriter);
        }
    }

    private void cleanupDataWriter() {
        if (dataMesgWriter != null) {
            dataMesgWriter.close();
        }
    }

    private void runVerificationTests() {
        System.out.println("Running FIT verification tests...");

        ActivityFileValidationPlugin plugin = new ActivityFileValidationPlugin();

        try {
            FileInputStream inputStream = new FileInputStream(inputFileName);

            FitDecoder fitDecoder = new FitDecoder();
            fitDecoder.decode(inputStream, plugin);

        } catch (java.io.IOException e) {
            System.out.println("IOException opening file: " + inputFileName);
        } catch (FitRuntimeException e) {
            System.out.println("FitRuntimeException decoding file: " + e.getMessage());
        } catch (Exception e) {
            System.out.println("Exception decoding file: " + e.getMessage());
        } finally {
            // If an exception occurred before onBroadcast() was called,
            // then the validation checks would not have been executed.
            // There may still be decoded messages that are worth validating,
            // so force the validation checks to execute. Some tests may be
            // skipped or fail.
            if (plugin.getResults().size() == 0) {
                plugin.repeatValidation();
            }

            System.out.println("Message Count: " + plugin.getMesgCount());

            for (ActivityFileValidationResult result : plugin.getResults()) {
                System.out.println(result);
                if (result.getDescription() != null) {
                    System.out.println("\t" + result.getDescription());
                }
            }
        }
    }

    public static void main(String args[]) {
        CSVTool tool = new CSVTool();
        tool.run(args);
    }

    private static void printUsage() {
        System.out.println("Usage: java -jar FitCSVTool.jar <options> <file>");
        System.out.println("      -b <FIT FILE> <CSV FILE>  FIT binary to CSV.");
        System.out.println("      -c <CSV FILE> <FIT FILE>  CSV to FIT binary.");
        System.out.println("      -t Enable file verification tests.");
        System.out.println("      -d Enable debug output.");
        System.out.println("      -i Check integrity of FIT file before decoding.");
        System.out.println("      -s Show invalid fields in the CSV file.");
        System.out.println("      -se Show invalid fields in the CSV file as empty cells.");
        System.out.println("      -u Hide unknown data and report statistics on how much is hidden.");
        System.out.println("      -x Print byte values as hexadecimal.");
        System.out.println("      -deg Print semicircle values as degrees.");
        System.out.println("      -iso8601 Print date-time values as ISO 8601 formatted strings.");
        System.out.println("      -ex Changes the behaviour of the --defn and --data options to");
        System.out.println("          filter out the messages listed. The default behaviour without");
        System.out.println("          this flag is to exclude all messages except those listed");
        System.out.println("          after the --defn and the --data options.");
        System.out.println("      -pN Encode file using Protocol Version <N>. Default: 1");
        System.out.println("      -e Print enum values as their corresponding String labels when");
        System.out.println("          possible. Note: CSV files generated with this option will not");
        System.out.println("          be able to be converted back into .FIT files.");
        System.out.println("      -re Remove expanded fields from CSV output. This removes fields");
        System.out.println("          that have been generated through component expansion and");
        System.out.println("          which do not exist in the source .FIT file");
        System.out.println("      --defn <MESSAGE_STRING_0,MESSAGE_STRING_1,...> Narrows down the");
        System.out.println("          definitions output to CSV. Use 'none' for no definitions");
        System.out.println("          When this option is used only the message definitions");
        System.out.println("          in the comma separated list will be written to the CSV.");
        System.out.println("          eg. --defn file_capabilities,record,file_creator");
        System.out.println("          Note: This option is only compatible with the -b option.");
        System.out.println("      --data <MESSAGE_STRING_0,MESSAGE_STRING_1,...> Narrows down the");
        System.out.println("          data output to CSV. When this option is used only the data");
        System.out.println("          in the comma separated list will be written to the csv.");
        System.out.println("          eg. --data file_capabilities,record,file_creator");
        System.out.println("          Note: This option is only compatible with the -b option.");
    }
}
